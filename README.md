# 🗂️ Project Structure Guide

This project follows a simple, extensible folder structure designed to be easily understood by any developer. Each layer has a clear responsibility, making the codebase predictable, maintainable, and scalable as the project grows.

---

## 1. Overview
The basic concept is about avoiding deep nesting. Instead of it we create clear layers. As the result a developer always knows where to put/find any file. Nobody needs to find the code across deep nested folders or resolve cross-imports or circular deps issues. Unlike a lot of other folder structures this one is dead simple wich increases the speed of onboarding proccess.

![image](https://github.com/user-attachments/assets/aa26bd07-0e5b-4c26-bb09-1ca8402a00f6)

---

## 2. Layers
Roles of each layer.

### 2.1 Pages
App routes. Pages might contain nested routes.

### 2.2 Featues
Feature is a UI use-case. Don't create giant fetures like `User`.
You'd better have something like `UserProfile` and `UsersSearchSestion` (can be deployed/deleted without breaking each other).
It allows you to write effective tests and avoid having folders that are to big to understand.

### 2.3 Components
This is the ui-kit of the app. They shouldn't use domain logic, make requests and etc.
Think about it as your own local MUI/Antd

### 2.4 Stores
View-model layer: Zustand, MobX, or Redux slices. Manages state, selectors, and derived values. 
Can depend on models/, but not vice versa

### 2.5 Models
This is the place for domain logic, enities, rules and etc.
This layer pure (doesn't have UI, doesn't rely on ViewModels)

### 2.6 Api
API clients, constants, and types for backend communication. May include autogenerated files (e.g. swagger-typescript-api).

### 2.7 Quieries
TanStack Query or SWR hooks for data fetching and mutation.
Example: useUserCreate.ts, useUserGet.ts.

### 2.8 Theme
Design system config: theme tokens, color palettes, spacing rules, and global CSS.

### 2.9 Config
Application-level configuration files. Includes runtime flags, environment settings, and static config maps.

### 2.9 Libs
Internal libraries or wrappers for 3rd-party tool.

### 2.10 Assets
Static resources such as images, icons, and fonts. Nested folders are grouped by the type (image, font and etc).

### 2.11 Utils
Non-domain-specific helpers. Pure, reusable code used across the app, without side effects.
There are nested folders like:
- helpers: pure JS functions
- hooks: reusabe React hooks
- constants: shared constants

### 2.12 Contexts
React context providers + hooks to use their data

---

## 3. Tips

### 3.1 Imports
Always use direct imports from specific modules.
For example: import { User } from '@model/user'.
Do not use barrel files like @model/index.ts

### 3.2 Collocation
Unit tests and css modules should be placed next to the file they're realted.
For example, if you have Button.tsx, there should be Button.test.tsx and Button.module.css in the same folder.

### 3.3 Collocation
Create context provider and the hook to access it in the same file.

## 4. Full example

```
src/
├─ pages/           # Route-level React components (entry points)
├─ features/        # Smart UI containers (use-case modules)
├─ components/      # Reusable UI components (UI kit)
├─ store/           # Zustand / MobX stores or Redux slices (ViewModels)
├─ api/             # API clients (services, constants, types)
├─ queries/         # TanStack/SWR queries and mutations
├─ theme/           # Theme provider and configuration
├─ config/          # App-level configuration
├─ libs/            # App libraries or wrappers (e.g., logger, event bus)
├─ assets/          # Static files (images, icons, fonts)
├─ models/          # Domain entities and business rules
├─ contexts/        # React context providers + hooks to access their data
└─ utils/           # Reusable non-domain utilities
   ├─ hooks/        # Common React hooks
   ├─ constants/    # App-wide constants
   └─ helpers/      # Generic pure functions
```
